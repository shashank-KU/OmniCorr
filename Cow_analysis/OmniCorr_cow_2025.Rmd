---
title: "OmniCorr: Cow Proteomics"
author: "Wanxin Lai"
date: '`r format(Sys.time(), "%d.%m.%Y")`'
output:
  html_document:
    toc: true
    toc_float: true
    theme: yeti
    code_folding: hide
    number_sections: false
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(stringsAsFactors = FALSE)

library(OmniCorr)
library(tidyverse)
library(imp4p)
library(WGCNA)
library(ggpubr)
library(reshape2)
library(vsn)
library(grid)
library(gridExtra)
library(ggplot2)
library(cowplot)

theme_set(theme_bw())
```

### Load data
```{r}
load("Omnicorr_cow_meta_traits.RData")
```

##### intro of data
```{r }

#metadata only with ch4 and split
head(meta)
# latest additional metadata}
#latest full metadata and other annotation misc
head(metadata)
#imputation group
groups
# Kegg annotation
#head(kegg_data_raw)
# MAGs(archae and bacteria associated with CH4)
head(combined_MAG_genome)
```

#### whatever raw intensity proteomics 

This is the raw intensity then.
```{r impute and normalise}
#filter T6
rawP <- newP_slim %>%
  mutate(sample = paste(animal, timepoint, sep ="")) %>% 
  filter(str_detect(sample, "T6")) %>% 
  mutate(sample = paste(source, animal,timepoint, sep = ""))

rawP_D <- rawP %>%
  filter(str_detect(source, "D")) %>% 
  select(protein, sample, intensity) 
matrx.rawP_D <- acast(rawP_D, protein ~ sample, value.var = "intensity", fun.aggregate = mean)
filtprot_D <- matrx.rawP_D[rowSums(is.nan(matrx.rawP_D)) <= ncol(matrx.rawP_D) - 3,]

ipt.metaP_D <- filtprot_D %>% 
  missForest()

vsn_fit_D <- vsn2(ipt.metaP_D$ximp)
meanSdPlot(vsn_fit_D)  

```


```{r wall}
#=================Wall matrix! ===================#
rawP_W <- rawP %>%
  filter(str_detect(source, "W")) %>% 
  select(protein, sample, intensity) 
matrx.rawP_W <- acast(rawP_W, protein ~ sample, value.var = "intensity", fun.aggregate = mean)
filtprot_W <- matrx.rawP_W[rowSums(is.nan(matrx.rawP_W)) <= ncol(matrx.rawP_W) - 3,]

ipt.metaP_W <- filtprot_W %>% 
  missForest()

vsn_fit_W <- vsn2(ipt.metaP_W$ximp)
meanSdPlot(vsn_fit_W)  
```


```{r include=FALSE}
matrx.rawP_L2 <-  rawP_L %>% pivot_wider(id_cols = protein, names_from = sample, values_from = intensity) 

imputedL.2 <- matrx.rawP_L2 %>% 
  column_to_rownames("protein") %>% 
  missForest()

out <- vsn::vsn2(as.matrix(imputedL.2$ximp))
# Extract the transformed data matrix from the vsn2 output
transformed_data <- exprs(out)

# Now  calculate the mean and standard deviation
mean_sd <- function(x) {
  data.frame(mean = mean(x), sd = sd(x))
}

# Apply the function to the entire transformed data
meanSdPlot(transformed_data)
liver2 <- transformed_data %>% 
  merge(., annoL[,1] %>% unique(), by.x = 0, by.y = "protein", all.x = T) %>% 
  rename_with(~ sub("^L", "", .), starts_with("L")) %>% 
  column_to_rownames("Row.names")

L.pca <- prcomp(t(liver2))$x

L.pca %>% 
  merge(., meta, by.x = 0, by.y = 0) %>% 
  #rownames_to_column(var = "Sample") %>% 
  dplyr::rename(sample = Row.names) %>% 
  ggplot(aes(x = PC1, y = PC2, col = split, label = sample, shape = ch4_dmi_binary)) +
  geom_point(size = 4) +
  geom_text(vjust = -0.6) +
  ggtitle("Proteomics(Host:Liver)")
  
```

##### Liver matrix! 
```{r}
#=================Liver matrix! ===================#
rawP_L <- rawP %>%
  filter(str_detect(source, "L")) %>% 
  select(protein, sample, intensity) 

matrx.rawP_L <- acast(rawP_L, protein ~ sample, value.var = "intensity", fun.aggregate = mean)
filtprot_L <- matrx.rawP_L[rowSums(is.nan(matrx.rawP_L)) <= ncol(matrx.rawP_L) - 3,]

#fill in missingness first so they were just treated as missing and wont distort the normalisation step
ipt.metaP_L <- filtprot_L %>% 
  missForest()

#vsn later to ensure variance across samples were adjusted and downstream comparisons are accurate 
vsn_fit_L <- vsn2(ipt.metaP_L$ximp)
meanSdPlot(vsn_fit_L)  
```

### After imputation.


```{r post normalisation check}
vsn_matrix_L <- predict(vsn_fit_L, newdata = ipt.metaP_L$ximp)
head(vsn_matrix_L)

vsn_matrix_W <- predict(vsn_fit_W, newdata = ipt.metaP_W$ximp)
head(vsn_matrix_W)

vsn_matrix_D <- predict(vsn_fit_D, newdata = ipt.metaP_D$ximp)
head(vsn_matrix_D)

```


##### Extract ciliates, fungi and host proteomics 
```{r}
# gene_id info that can match to new_metaP
annoD <- newP_slim%>% 
  filter(str_detect(timepoint, "T6")) %>% 
  filter(str_detect(source, "D"))

# for liver and wall
annoL <- newP_slim %>% 
  filter(str_detect(timepoint, "T6"))%>% 
  filter(str_detect(source, "L"))

annoW <- newP_slim %>% 
  filter(str_detect(timepoint, "T6")) %>% 
  filter(str_detect(source, "W"))

# Extract ciliates protein id
# unique(sub(".*\\|", "", test$max_annot_lvl))
#======================================================================================#

# Isolate ciliates from Digesta samples
annotation_ciliates <- annoD %>%
  filter(tax_phylum == "Ciliophora")

annotation_fungi <- annoD %>%
  filter(str_detect(tax_phylum, "Neocallimastigomycota"))

#Extract cow
annotation_metazoa <- annoD %>%
  filter(tax_genus == "Bos")

# Making new meta_proteomics data *bacteria from hmsc + archae

# 1) Extract protein from MAGs associated with CH4 directional response 
head(combined_MAG_genome)

# 1.2) Include methanogenic archae
archae <- annoD[annoD$tax_kingdom == "Archaea",]

matching_T6_archae_bacteria <- annoD %>%
  filter(tax_phylum %in% combined_MAG_genome) %>% 
  rbind(., archae)

matching_T6_ciliates <- merge(vsn_matrix_D, annotation_ciliates[,1] %>%
                                unique(), by.x = 0, by.y = "protein")
ciliates <- matching_T6_ciliates %>%
  rename_with(~ sub("^D", "", .), starts_with("D")) %>% 
  column_to_rownames("Row.names")

#=====================================###
matching_T6_fungi <- merge(vsn_matrix_D, annotation_fungi[,1] %>%
                             unique(), by.x = 0, by.y = "protein")
fungi <- matching_T6_fungi %>%
  rename_with(~ sub("^D", "", .), starts_with("D")) %>%
  column_to_rownames("Row.names")

#===================================###
#extract cow digesta
matching_T6_metazoa <- merge(vsn_matrix_D, annotation_metazoa[,1] %>% unique(), by.x = 0, by.y = "protein")
metazoa <- matching_T6_metazoa %>%
  rename_with(~ sub("^D", "", .), starts_with("D")) %>%
  column_to_rownames("Row.names")

#extract cow liver
matching_T6_metL <- merge(vsn_matrix_L, annoL[,1] %>% unique(), by.x = 0, by.y = "protein", all.x = T)
metL <- matching_T6_metL %>% 
  rename_with(~ sub("^L", "", .), starts_with("L")) %>% 
  column_to_rownames("Row.names")

#===================================###
#extract archae bacteria

matching_T6_metaP <- merge(vsn_matrix_D, matching_T6_archae_bacteria[,1] %>% unique(), by.x = 0, by.y = "protein")
archbac <- matching_T6_metaP %>%
  rename_with(~ sub("^D", "", .), starts_with("D")) %>%
  column_to_rownames("Row.names")

#==================================###
#extract cow wall
matching_T6_metW <- merge(vsn_matrix_W, annoW[,1] %>% unique(), by.x = 0, by.y = "protein")
metW <- matching_T6_metW %>% 
  rename_with(~ sub("^W", "", .), starts_with("W")) %>% 
  column_to_rownames("Row.names")

```


```{r pca}

meta <- meta %>% 
  left_join(., data.frame(sample = colnames(ciliates)), by= "sample") %>% 
  column_to_rownames(var = "sample")
  
ciliates.pca <- prcomp(t(ciliates))$x 

c.p <- ciliates.pca %>% 
  merge(., meta, by.x = 0, by.y = 0, all.x = T) %>% 
  #(var = "Sample") %>% 
  dplyr::rename(sample = Row.names) %>% 
  ggplot(aes(x = PC1, y = PC2, col = split, label = sample, shape = ch4_dmi_binary)) +
  geom_point(size = 4) +
  geom_text(vjust = -0.6) +
  ggtitle("Proteomics(Ciliates)")

fungi.pca <- prcomp(t(fungi))$x 

f.p <- fungi.pca %>% 
  merge(., meta, by.x = 0, by.y = 0, all.x = T) %>% 
  #rownames_to_column(var = "Sample") %>% 
  dplyr::rename(sample = Row.names) %>% 
  ggplot(aes(x = PC1, y = PC2, col = split, label = sample, shape = ch4_dmi_binary)) +
  geom_point(size = 4) +
  geom_text(vjust = -0.6) +
  ggtitle("Proteomics(Fungi)")

archbac.pca <- prcomp(t(archbac))$x 

a.p <- archbac.pca %>% 
  merge(., meta, by.x = 0, by.y = 0, all.x = T) %>% 
  #rownames_to_column(var = "Sample") %>% 
  dplyr::rename(sample = Row.names) %>% 
  ggplot(aes(x = PC1, y = PC2, col = split, label = sample, shape = ch4_dmi_binary)) +
  geom_point(size = 4) +
  geom_text(vjust = -0.6) +
  ggtitle("Proteomics(Archae and Bacteria)")

metazoa.pca <- prcomp(t(metazoa))$x 

m.p <- metazoa.pca %>% 
  merge(., meta, by.x = 0, by.y = 0, all.x = T) %>% 
  #rownames_to_column(var = "Sample") %>% 
  dplyr::rename(sample = Row.names) %>% 
  ggplot(aes(x = PC1, y = PC2, col = split, label = sample, shape = ch4_dmi_binary)) +
  geom_point(size = 4) +
  geom_text(vjust = -0.6) +
  ggtitle("Proteomics(Host:Digesta)")


metL.pca <- prcomp(t(metL))$x 

mL.p <- metL.pca %>% 
  merge(., meta, by.x = 0, by.y = 0, all.x = T) %>% 
  #rownames_to_column(var = "Sample") %>% 
  dplyr::rename(sample = Row.names) %>% 
  ggplot(aes(x = PC1, y = PC2, col = split, label = sample, shape = ch4_dmi_binary)) +
  geom_point(size = 4) +
  geom_text(vjust = -0.6) +
  ggtitle("Proteomics(Host:Liver)")


metW.pca <- prcomp(t(metW))$x 

mW.p <- metW.pca %>% 
  merge(., meta, by.x = 0, by.y = 0, all.x = T) %>% 
  #rownames_to_column(var = "Sample") %>% 
  dplyr::rename(sample = Row.names) %>% 
  ggplot(aes(x = PC1, y = PC2, col = split, label = sample, shape = ch4_dmi_binary)) +
  geom_point(size = 4) +
  geom_text(vjust = -0.6) +
  ggtitle("Proteomics(Host:Wall)")

cowplot::plot_grid(c.p, f.p, a.p, m.p, mL.p, mW.p)

```


```{r wgcna}
if (!file.exists("Modules.RData")) {

  minModuleSize = 20
  
# Modules: ciliates proteomics
  
  powers = c(c(1:10), seq(from = 12, to=20, by=2))
  sft = pickSoftThreshold(t(ciliates), powerVector = powers, corFnc = "bicor", networkType = "signed", verbose = 0)
  
  # Plot the results
  cex1 = 0.9;
  # Scale-free topology fit index as a function of the soft-thresholding power
  plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
       xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit R^2",type="n",
       main = paste("Scale independence"));
  text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
       labels=powers,cex=cex1,col="red");
  # this line corresponds to using an R^2 cut-off of h
  abline(h=0.80,col="red")
  
  power <- 9
  
  Ciliates.modules <- blockwiseModules(datExpr = t(ciliates),
                                 power = power, 
                                 maxBlockSize = 8000, 
                                 minModuleSize = minModuleSize, 
                                 networkType = "signed", 
                                 OMType = "signed", 
                                 corType = "bicor", 
                                 maxPOutliers = 0.05, 
                                 replaceMissingAdjacencies = TRUE, 
                                 pamStage = F, 
                                 deepSplit = 4, 
                                 minKMEtoStay = 0.5, 
                                 minCoreKME = 0.5, 
                                 minCoreKMESize = 2, 
                                 reassignThreshold = 0,
                                 mergeCutHeight = 0.2)
  
  #chooseTopHubInEachModule(datExpr = t(Proteomics.data), colorh = Proteomics.modules$colors, power = power, type = "signed")
  
  
  # Modules: fungi proteomics
  
  powers = c(c(1:10), seq(from = 12, to=20, by=2))
  sft = pickSoftThreshold(t(fungi), powerVector = powers, corFnc = "bicor", networkType = "signed", verbose = 0)
  
  # Plot the results
  cex1 = 0.9;
  # Scale-free topology fit index as a function of the soft-thresholding power
  plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
       xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit R^2",type="n",
       main = paste("Scale independence"));
  text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
       labels=powers,cex=cex1,col="red");
  # this line corresponds to using an R^2 cut-off of h
  abline(h=0.80,col="red")
  
  power <- 14 # 0.75
  
  Fungi.modules <- blockwiseModules(datExpr = t(fungi),
                                 power = power, 
                                 maxBlockSize = 8000, 
                                 networkType = "signed", 
                                 OMType = "signed", 
                                 corType = "bicor", 
                                 maxPOutliers = 0.05, 
                                 replaceMissingAdjacencies = TRUE, 
                                 pamStage = F, 
                                 deepSplit = 4, 
                                 minModuleSize = 5, 
                                 minKMEtoStay = 0.5, 
                                 minCoreKME = 0.5, 
                                 minCoreKMESize = 2, 
                                 reassignThreshold = 0,
                                 mergeCutHeight = 0.2)
  
  # Modules: Archae and Bacteria proteomics
  
  powers = c(c(1:10), seq(from = 12, to=30, by=2))
  sft = pickSoftThreshold(t(archbac), powerVector = powers, corFnc = "bicor", networkType = "signed", verbose = 0)
  
  # Plot the results
  cex1 = 0.9;
  # Scale-free topology fit index as a function of the soft-thresholding power
  plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
       xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit R^2",type="n",
       main = paste("Scale independence"));
  text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
       labels=powers,cex=cex1,col="red");
  # this line corresponds to using an R^2 cut-off of h
  abline(h=0.80,col="red")
  
  power <- 9
  
  Archbac.modules <- blockwiseModules(datExpr = t(archbac),
                                 power = power, 
                                 maxBlockSize = 8000, 
                                 networkType = "signed", 
                                 OMType = "signed", 
                                 corType = "bicor", 
                                 maxPOutliers = 0.05, 
                                 replaceMissingAdjacencies = TRUE, 
                                 pamStage = F, 
                                 deepSplit = 4, 
                                 minModuleSize = minModuleSize, 
                                 minKMEtoStay = 0.5, 
                                 minCoreKME = 0.5, 
                                 minCoreKMESize = 2, 
                                 reassignThreshold = 0,
                                 mergeCutHeight = 0.2)
  
   # Modules: Metazoa(Digesta) proteomics
  
  powers = c(c(1:10), seq(from = 12, to=20, by=2))
  sft = pickSoftThreshold(t(metazoa), powerVector = powers, corFnc = "bicor", networkType = "signed", verbose = 0)
  
  # Plot the results
  cex1 = 0.9;
  # Scale-free topology fit index as a function of the soft-thresholding power
  plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
       xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit R^2",type="n",
       main = paste("Scale independence"));
  text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
       labels=powers,cex=cex1,col="red");
  # this line corresponds to using an R^2 cut-off of h
  abline(h=0.80,col="red")
  
  power <- 16
  
  Metazoa.modules <- blockwiseModules(datExpr = t(metazoa),
                                 power = power, 
                                 maxBlockSize = 8000, 
                                 networkType = "signed", 
                                 OMType = "signed", 
                                 corType = "bicor", 
                                 maxPOutliers = 0.05, 
                                 replaceMissingAdjacencies = TRUE, 
                                 pamStage = F, 
                                 deepSplit = 4, 
                                 minModuleSize = 5, 
                                 minKMEtoStay = 0.5, 
                                 minCoreKME = 0.5, 
                                 minCoreKMESize = 2, 
                                 reassignThreshold = 0,
                                 mergeCutHeight = 0.2)
  
  # Modules: Metazoa(liver) proteomics
  
  powers = c(c(1:10), seq(from = 12, to=20, by=2))
  sft = pickSoftThreshold(t(metL), powerVector = powers, corFnc = "bicor", networkType = "signed", verbose = 0)
  
  # Plot the results
  cex1 = 0.9;
  # Scale-free topology fit index as a function of the soft-thresholding power
  plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
       xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit R^2",type="n",
       main = paste("Scale independence"));
  text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
       labels=powers,cex=cex1,col="red");
  # this line corresponds to using an R^2 cut-off of h
  abline(h=0.80,col="red")
  
  power <- 14
  
  MetL.modules <- blockwiseModules(datExpr = t(metL),
                                 power = power, 
                                 maxBlockSize = 8000, 
                                 networkType = "signed", 
                                 OMType = "signed", 
                                 corType = "bicor", 
                                 maxPOutliers = 0.05, 
                                 replaceMissingAdjacencies = TRUE, 
                                 pamStage = F, 
                                 deepSplit = 4, 
                                 minModuleSize = 5, 
                                 minKMEtoStay = 0.5, 
                                 minCoreKME = 0.5, 
                                 minCoreKMESize = 2, 
                                 reassignThreshold = 0,
                                 mergeCutHeight = 0.2)
  
  # Modules: Metazoa(wall) proteomics
  
  powers = c(c(1:10), seq(from = 12, to=25, by=2))
  sft = pickSoftThreshold(t(metW), powerVector = powers, corFnc = "bicor", networkType = "signed", verbose = 0)
  
  # Plot the results
  cex1 = 0.9;
  # Scale-free topology fit index as a function of the soft-thresholding power
  plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
       xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit R^2",type="n",
       main = paste("Scale independence"));
  text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
       labels=powers,cex=cex1,col="red");
  # this line corresponds to using an R^2 cut-off of h
  abline(h=0.80,col="red")
  
  
  power <- 28
  
  MetW.modules <- blockwiseModules(datExpr = t(metW),
                                 power = power, 
                                 maxBlockSize = 8000, 
                                 networkType = "signed", 
                                 OMType = "signed", 
                                 corType = "bicor", 
                                 maxPOutliers = 0.05, 
                                 replaceMissingAdjacencies = TRUE, 
                                 pamStage = F, 
                                 deepSplit = 4, 
                                 minModuleSize = 5, 
                                 minKMEtoStay = 0.5, 
                                 minCoreKME = 0.5, 
                                 minCoreKMESize = 2, 
                                 reassignThreshold = 0,
                                 mergeCutHeight = 0.2)
  
  save(Ciliates.modules, Fungi.modules, Archbac.modules, Metazoa.modules, MetL.modules, MetW.modules, file = "Modules19092024.RData")
}

#load("Modules19092024.RData")


Ciliates_protmics <- Ciliates.modules$MEs
Fungi_protmics <- Fungi.modules$MEs
Archbac_protmics <- Archbac.modules$MEs
Metazoa_protmics <- Metazoa.modules$MEs
MetLiver_protmics <- MetL.modules$MEs
MetWall_protmics <- MetW.modules$MEs
```


```{r}
# Ciliates proteomics: Correlation within modules
kME <- bicor(t(ciliates), Ciliates_protmics, maxPOutliers = 0.05)

intra_cor <- c()
for (i in 1:nrow(ciliates)) {
  m <- Ciliates.modules$colors[i]
  if (m != "grey") {
    intra_cor[i] <- kME[i, paste0("ME", m)]
  }
}

data.frame(Correlation = intra_cor) %>% 
  ggplot(aes(x = Correlation)) +
  geom_histogram() +
  xlim(-1,1) +
  ggtitle("Ciliates proteomics: Within module correlation")
```

```{r}

# Archae and Bacteria proteomics: Correlation within modules
kME <- bicor(t(archbac), Archbac_protmics, maxPOutliers = 0.05)

intra_cor <- c()
for (i in 1:nrow(archbac)) {
  m <- Archbac.modules$colors[i]
  if (m != "grey") {
    intra_cor[i] <- kME[i, paste0("ME", m)]
  }
}

data.frame(Correlation = intra_cor) %>% 
  ggplot(aes(x = Correlation)) +
  geom_histogram() +
  xlim(-1,1) +
  ggtitle("Archae and bacteria proteomics: Within module correlation")
```

```{r}
# Metaproteomics: Correlation within modules
kME <- bicor(t(metL), MetLiver_protmics, maxPOutliers = 0.05)

intra_cor <- c()
for (i in 1:nrow(metL)) {
  m <- MetL.modules$colors[i]
  if (m != "grey") {
    intra_cor[i] <- kME[i, paste0("ME", m)]
  }
}

data.frame(Correlation = intra_cor) %>% 
  ggplot(aes(x = Correlation)) +
  geom_histogram() +
  xlim(-1,1) +
  ggtitle("Host(liver): Within module correlation")

```

```{r}
# Proteomics: Correlation within modules
kME <- bicor(t(metazoa), Metazoa_protmics, maxPOutliers = 0.05)

intra_cor <- c()
for (i in 1:nrow(metazoa)) {
  m <- Metazoa.modules$colors[i]
  if (m != "grey") {
    intra_cor[i] <- kME[i, paste0("ME", m)]
  }
}

data.frame(Correlation = intra_cor) %>% 
  ggplot(aes(x = Correlation)) +
  geom_histogram() +
  xlim(-1,1) +
  ggtitle("Metazoa proteomics: Within module correlation")
```

```{r}
kME <- bicor(t(metW), MetWall_protmics, maxPOutliers = 0.05)

intra_cor <- c()
for (i in 1:nrow(metW)) {
  m <- MetW.modules$colors[i]
  if (m != "grey") {
    intra_cor[i] <- kME[i, paste0("ME", m)]
  }
}

data.frame(Correlation = intra_cor) %>% 
  ggplot(aes(x = Correlation)) +
  geom_histogram() +
  xlim(-1,1) +
  ggtitle("Host Wall: Within module correlation")
```


#### Step 1.1: Perform hierarchical clustering of the central omics layer (metaProteomics) using WGCNA

```{r}

dendro.rows <- hclust(as.dist(1 - WGCNA::bicor(Archbac_protmics, maxPOutliers = 0.05)), method = "ward.D2")
dendro.cols <- hclust(as.dist(1 - WGCNA::bicor(t(Archbac_protmics), maxPOutliers = 0.05)), method = "ward.D2")
plot(dendro.rows)
```

### Step 2.1: Generate a heatmap of the central omics layer with dendrogram

```{r}
#meta$split <- as.factor(meta$split)
meta$treatment <- as.factor(meta$treatment)
meta$breed <- as.factor(meta$breed)

# Chnage colname to capital
colnames(meta)[colnames(meta) == 'treatment'] <- 'Treatment'
colnames(meta)[colnames(meta) == 'breed'] <- 'Breed'

result2 <- pheatmap::pheatmap(t(Archbac_protmics)[,dendro.cols$order], 
                              cluster_rows = dendro.rows, 
                              cluster_cols = dendro.cols, treeheight_col = 0, 
                              show_rownames = T, 
                              #fontsize_row = 6.5,
                              #fontsize_col = 6.5,
                              main = paste("Methanogenic","& archae bacteria", sep = "\n"),
                              annotation_col = meta %>%  select(Treatment, Breed), 
                              annotation_legend = T)


```


### Step 3: Calculate correlations between omics data

```{r corr archbac cow}

result3 <- calculate_correlations(df1 = Archbac_protmics, 
                                  df2 = Metazoa_protmics,
                                  method = "pearson",
                                  show_significance = "stars" # Possible other values are "p_value" or "correlation"
)

#================== select modules from cow that has significant association============#
# Convert the p-value matrix from character to numeric
p_values_numeric <- apply(result3$p_value, 2, as.numeric)

# Identify columns with p-values less than 0.05 in any row
#cols_to_keep <- apply(p_values_numeric, 2, function(col) any(col < 0.05))
cols_to_keep <- as.data.frame(p_values_numeric, row.names = rownames(result3$p_value))["MEdarkgreen",] < 0.05 #check which columns have p-value < 0.05 in row 13(darkgreen)

# Subset matrices based on the identified columns
result3$p_value <- result3$p_value[, cols_to_keep]
result3$correlation <- result3$correlation[, cols_to_keep]
result3$signif_matrix <- result3$signif_matrix[, cols_to_keep]

# Now the matrices in result3 will contain only columns with p-values < 0.05
```

```{r corr archbac ciliates}

result3.1 <- calculate_correlations(df1 = Archbac_protmics, 
                                    df2 = Ciliates_protmics,
                                    method = "pearson",
                                    show_significance = "stars" # Possible other values are "p_value" or "correlation"
)

# Convert the p-value matrix from character to numeric
p_values_numeric <- apply(result3.1$p_value, 2, as.numeric)

# Identify columns with p-values less than 0.05 in any row
#cols_to_keep <- apply(p_values_numeric, 2, function(col) any(col < 0.05))
cols_to_keep <- as.data.frame(p_values_numeric, row.names = rownames(result3.1$p_value))["MEdarkgreen",] < 0.05 #check which columns have p-value < 0.05 in row 13 (MEdarkgreen)

# Subset matrices based on the identified columns
result3.1$p_value <- result3.1$p_value[, cols_to_keep]
result3.1$correlation <- result3.1$correlation[, cols_to_keep]
result3.1$signif_matrix <- result3.1$signif_matrix[, cols_to_keep]

# Now the matrices in result3 will contain only columns with p-values < 0.05

```

```{r corr archbac fungi}

result3.2 <- calculate_correlations(df1 = Archbac_protmics, 
                                    df2 = Fungi_protmics,
                                    method = "pearson",
                                    show_significance = "stars" # Possible other values are "p_value" or "correlation"
)

# Convert the p-value matrix from character to numeric
p_values_numeric <- apply(result3.2$p_value, 2, as.numeric)

# Identify columns with p-values less than 0.05 in any row
#cols_to_keep <- apply(p_values_numeric, 2, function(col) any(col < 0.05))
cols_to_keep <- as.data.frame(p_values_numeric, row.names = rownames(result3.2$p_value))["MEdarkgreen",] < 0.05 #check which columns have p-value < 0.05 in row 13(darkgreen)

# Subset matrices based on the identified columns
result3.2$p_value <- result3.2$p_value[, cols_to_keep]
result3.2$correlation <- result3.2$correlation[, cols_to_keep]
result3.2$signif_matrix <- result3.2$signif_matrix[, cols_to_keep]

# Now the matrices in result3 will contain only columns with p-values < 0.05
```

### Step 3.1: Calculate correlations between omics(metaproteomics) data

```{r include = FALSE, eval = FALSE}

result3 <- calculate_correlations(df1 = Proteomics, 
                                  df2 = Metaproteomics,
                                  method = "spearson",
                                  show_significance = "stars" # Possible other values are "p_value" or "correlation"
)

result3.1 <- calculate_correlations(df1 = Metaproteomics, 
                                    df2 = Ciliates_protmics,
                                    method = "spearman",
                                    show_significance = "stars" # Possible other values are "p_value" or "correlation"
)

result3.2 <- calculate_correlations(df1 = Metaproteomics, 
                                    df2 = Fungi_protmics,
                                    method = "spearman",
                                    show_significance = "stars" # Possible other values are "p_value" or "correlation"
)

```


### Step 4: Generate a heatmap of the correlations between the central layer and other layers

```{r heatmap single matrix}

heatmap_colors <- colorRampPalette(rev(RColorBrewer::brewer.pal(n = 6, name ="RdBu")))(51)

result4 <- pheatmap::pheatmap(result3$correlation, 
                              color = heatmap_colors, 
                              treeheight_col = 0, 
                              treeheight_row = 0,
                              cluster_rows = dendro.rows,
                              cluster_cols = T,
                              #fontsize_col = 6.5,
                              #cutree_rows = row_cut,
                              display_numbers = result3$signif_matrix, 
                              breaks = seq(from = -1, to = 1, length.out = 51), 
                              show_rownames = F, legend = F,
                              labels_row = paste0(rownames(result3$correlation)),
                              labels_col = paste0(colnames(result3$correlation)),
                              #main = paste("Metaproteomics"))
                              main = paste("Host", "\n (Digesta Fluid)", sep = ""))


heatmap_colors <- colorRampPalette(rev(RColorBrewer::brewer.pal(n = 6, name ="RdBu")))(51)

result4.1 <- pheatmap::pheatmap(result3.1$correlation, 
                              color = heatmap_colors, 
                              treeheight_col = 0, 
                              treeheight_row = 0,
                              #fontsize_col = 6,
                              cluster_rows = dendro.rows,
                              #cutree_rows = row_cut,
                              display_numbers = result3.1$signif_matrix, 
                              breaks = seq(from = -1, to = 1, length.out = 51), 
                              show_rownames = F, legend = F,
                              labels_row = paste0(rownames(result3.1$correlation)),
                              labels_col = paste0(colnames(result3.1$correlation)),
                              main = paste("Ciliates", "\n (Digesta Fluid)", sep = ""))

heatmap_colors <- colorRampPalette(rev(RColorBrewer::brewer.pal(n = 6, name ="RdBu")))(51)

result4.2 <- pheatmap::pheatmap(result3.2$correlation, 
                              color = heatmap_colors, 
                              treeheight_col = 0, 
                              treeheight_row = 0,
                              cluster_rows = dendro.rows,
                              #fontsize_col = 6.5,
                              #cutree_rows = row_cut,
                              display_numbers = result3.2$signif_matrix, 
                              breaks = seq(from = -1, to = 1, length.out = 51), 
                              show_rownames = F, legend = F,
                              labels_row = paste0(rownames(result3.2$correlation)),
                              labels_col = paste0(colnames(result3.2$correlation)),
                              main = paste("Fungi", "\n (Digesta Fluid)", sep = ""))
```


### Step 5: Combine the heatmap of transcriptomics data and the heatmap of correlations

```{r}

cowplot::plot_grid(result2$gtable, 
                   result4$gtable,
                   result4.1$gtable,
                   result4.2$gtable,
                   ncol = 4,  align = 'h',
                   rel_widths = c(1.5, 0.8,1.6,0.5)) + 
  ggplot2::theme(plot.margin = ggplot2::unit(c(2,1,1,1), "cm"))

```

### Step 6: Integrate the meta-data heatmap

```{r}

meta_cln <- meta %>% 
  mutate(Breed = as.numeric(factor(Breed)) - 1) %>% 
  #mutate(treatment = as.numeric(factor(treatment)) - 1) %>% 
  mutate(ch4_dmi_binary = as.numeric(factor(ch4_dmi_binary, levels = c("low", "high"))) - 1) #%>% 
  #mutate(split = as.numeric(factor(split)) - 1)

#meta_cln <- meta %>% filter(str_detect(sample, "T6")) %>% 
 # filter(sample %in% rownames(Archbac_protmics)) %>%
  #column_to_rownames("sample")

all(rownames(meta_cln) == row.names(Archbac_protmics))
#all(meta$sample == row.names(Proteomics))

result_pheno_H <- calculate_correlations(df1 = Archbac_protmics, 
                                    df2 = meta_cln[rownames(Archbac_protmics),] %>% select(Breed, ch4_dmi_binary), 
                                    use = "pairwise.complete.obs", # default is "all.obs"
                                    method = "pearson",
                                    show_significance = "stars" # Possible other values are "p_value" or "correlation"
)

#====================

# Convert the p-value matrix to a data frame (if necessary)
p_value_df <- as.data.frame(result_pheno_H$p_value, row.names = rownames(result_pheno_H$p_value))

# Keep only rows where any value in the row is smaller than 0.05
# checks each row of the data frame to see if any value is smaller than 0.05. 
# The apply() function is used to loop through rows (with 1 specifying rows).
rows_to_keep <- apply(p_value_df, 1, function(row) any(as.numeric(row) <= 0.05))

key_module <- paste(rownames(p_value_df[rows_to_keep,]), collapse = ",")

#===========



result_pheno_L <- calculate_correlations(df1 = Archbac_protmics, 
                                    df2 = MetLiver_protmics[rownames(Archbac_protmics),], 
                                    use = "pairwise.complete.obs", # default is "all.obs"
                                    method = "pearson",
                                    show_significance = "stars" # Possible other values are "p_value" or "correlation"
)

# Convert the p-value matrix from character to numeric
p_val_numeric <- apply(result_pheno_L$p_value, 2, as.numeric)

# Identify columns with p-values less than 0.05 in any row
#cols_to_keep <- apply(p_values_numeric, 2, function(col) any(col < 0.05))
cols_to_keep <- as.data.frame(p_val_numeric, row.names = rownames(result_pheno_L$p_value))[key_module,] < 0.05 #check which columns have p-value < 0.05 in row 13(darkgreen)

# Subset matrices based on the identified columns
result_pheno_L$p_value <- result_pheno_L$p_value[, cols_to_keep]
result_pheno_L$correlation <- result_pheno_L$correlation[, cols_to_keep]
result_pheno_L$signif_matrix <- result_pheno_L$signif_matrix[, cols_to_keep]


result_pheno_W <- calculate_correlations(df1 = Archbac_protmics, 
                                    df2 = MetWall_protmics, 
                                    use = "pairwise.complete.obs", # default is "all.obs"
                                    method = "pearson",
                                    show_significance = "stars" # Possible other values are "p_value" or "correlation"
)

# Convert the p-value matrix from character to numeric
p_val_numeric <- apply(result_pheno_W$p_value, 2, as.numeric)

# Identify columns with p-values less than 0.05 in any row
#cols_to_keep <- apply(p_values_numeric, 2, function(col) any(col < 0.05))
cols_to_keep <- as.data.frame(p_val_numeric, row.names = rownames(result_pheno_W$p_value))[key_module,] < 0.05 #check which columns have p-value < 0.05 in row 13(darkgreen)

# Subset matrices based on the identified columns
result_pheno_W$p_value <- result_pheno_W$p_value[, cols_to_keep]
result_pheno_W$correlation <- result_pheno_W$correlation[, cols_to_keep]
result_pheno_W$signif_matrix <- result_pheno_W$signif_matrix[, cols_to_keep]


heatmap_colors <- colorRampPalette(rev(RColorBrewer::brewer.pal(n = 6, name ="RdBu")))(51)

# "META" corr of archbac and meta
result5 <- pheatmap::pheatmap(result_pheno_H$correlation, 
                                color = heatmap_colors, 
                                treeheight_col = 0, 
                                treeheight_row = 0,
                                cluster_rows = dendro.rows,
                                #cutree_rows = row_cut,
                                display_numbers = result_pheno_H$signif_matrix, 
                                breaks = seq(from = -1, to = 1, length.out = 51), 
                                show_rownames = F, legend = F,
                                labels_row = paste0(rownames(result_pheno_H$correlation)),
                                labels_col = paste0(colnames(result_pheno_H$correlation)),
                                main = paste("Metadata"))

# archbac with WALL
result6 <- pheatmap::pheatmap(result_pheno_W$correlation, 
                                color = heatmap_colors, 
                                treeheight_col = 0, 
                                treeheight_row = 0,
                                cluster_rows = dendro.rows,
                                #fontsize_col = 6.5, 
                                #cutree_rows = row_cut,
                                display_numbers = result_pheno_W$signif_matrix, 
                                breaks = seq(from = -1, to = 1, length.out = 51), 
                                show_rownames = F, legend = T,
                                labels_row = paste0(rownames(result_pheno_W$correlation)),
                                labels_col = paste0(colnames(result_pheno_W$correlation)),
                                main = paste("Host", "\n (Digesta Wall)", sep = ""))
#correlate archbac with liver
result7 <- pheatmap::pheatmap(result_pheno_L$correlation, 
                                color = heatmap_colors, 
                                treeheight_col = 0, 
                                treeheight_row = 0,
                                cluster_rows = dendro.rows,
                                #cutree_rows = row_cut,
                                display_numbers = result_pheno_L$signif_matrix, 
                                breaks = seq(from = -1, to = 1, length.out = 51), 
                                show_rownames = F, legend = F,
                                labels_row = paste0(rownames(result_pheno_L$correlation)),
                                labels_col = paste0(colnames(result_pheno_L$correlation)),
                                main = paste("Host Liver"))



cowplot::plot_grid(result5$gtable,
                   result2$gtable,
                   result6$gtable,
                   result7$gtable,
                   #result4.1$gtable,  # Meta heatmap correlation
                   ncol = 4, # change this based upon the number of omics heatmap
                   align = 'h',
                   rel_widths = c(0.2,1.5,0.2,1)) + 
  ggplot2::theme(plot.margin = ggplot2::unit(c(2,1,1,1), "cm"))


```
Wall and emission has some relationship.
```{r}
cowplot::plot_grid(result5$gtable,
                   result2$gtable,
                   result7$gtable,
                   #result4.1$gtable,  # Meta heatmap correlation
                   ncol = 3, # change this based upon the number of omics heatmap
                   align = 'h',
                   rel_widths = c(0.2,1,2.2)) + 
  ggplot2::theme(plot.margin = ggplot2::unit(c(2,1,1,1), "cm"))

```

Liver is not bad too.
```{r}
cowplot::plot_grid(result5$gtable, # External heatmap correlation
                   result2$gtable,  # Proteomics heatmap correlation
                   result4.1$gtable, # Meta(ciliates) heatmap correlation
                   result4.2$gtable,
                   result4$gtable,
                   result7$gtable,
                   result6$gtable,
                   ncol = 7, # change this based upon the number of omics heatmap
                   align = 'h',
                   rel_widths = c(0.1, 1.5, 0.3, 0.1, 0.25, 0.45, 0.2)) + 
  ggplot2::theme(plot.margin = ggplot2::unit(c(1.8,1,1,1), "cm"))

```


```{r}
data.frame(Module = Archbac.modules$colors) %>% 
  rownames_to_column(var = "Protein") %>% 
  filter(Module == "black") %>% 
  pull(Protein) -> proteins

selected_protein_info <- data.frame()

for(i in 1:length(as.vector(proteins))){
  holder <- annoD[annoD$protein == as.vector(proteins)[i],]
  selected_protein_info <- rbind(selected_protein_info, holder)
}

selected_archbac <- selected_protein_info[,c("protein","tax_kingdom", "tax_phylum", "tax_species","Description",  "KEGG_ko", "KEGG_Pathway", "KEGG_Module", "EC", "GOs", "CAZy" )] %>% unique() #%>% drop_na()


selected_archbac$KEGG_Module %>% unique()
```

```{r}
net_results <- list(Archbac.modules,
                    Ciliates.modules,
                    Fungi.modules,
                    Metazoa.modules,
                    MetL.modules,
                    MetW.modules)

for (i in 1:6) {
  net_results[[i]]$group_index <- groups$group_index[i]
}

```

# KeGG Functional Enrichment (Supplement liao)


```{r KeGG annotations housekeeping}
# --- Housekeeping

kegg_data <- kegg_data_raw %>%
    rename(ko_id = ortholog_ko)

annotations_file <- "results/annotation/annotation.emapper.annotations"
annotations_raw <- read_tsv(annotations_file, skip = 4, comment = "##", na = "-")

annotations_all <- annotations_raw %>%
    rename(query = `#query`) %>%
    # select(`#query`, starts_with("KEGG_"))
    # head(100) %>%
    separate_wider_regex(
        query,
        c(
            database_short = "^db[A-Z]",
            "\\d*\\|", # Crucial to not be greedy, but rather accept only a digit.
            protein_short = "[^ ]+", # Anything but a space.
            ".*$"
        ),
        cols_remove = F
    ) %>%
    mutate(protein = paste0(database_short, "|", protein_short)) %>%
    relocate(protein)

annotations <- annotations_all %>%
    select(-database_short, -protein_short, -query)

rm(annotations_all, annotations_raw)

```

```{r}
# Hierarchy used for sorting
pathway_hierarchy <- kegg_data %>%
    distinct(pathway_class = class, pathway_group = group, pathway) %>%
    arrange(pathway_class, pathway_group, pathway)
#handful(pathway_hierarchy)


# Geneset
term2gene <- kegg_data %>%
    select(term = pathway, gene = ko_id)
#term2gene %>% handful()

```

```{r}

# Add the annotation to the proteins of a single layer.
# This makes sense, since one protein is only present in one module.

# This is the most fucked up un-debuggable nested lapply on group_split()-ted tables I've ever done. written by carl


pe_analyses <- list()

for(i in seq_along(net_results)){
      #print(str(i)) DEbugging
      #Wanxin's thought: i is a numeric vector, not a data frame or list.
      message("group ", paste(i, collapse = ", "))
      
        #Wanxin added this and stack():
      group_index_value <- i 
      
      # stack() convert the named vector into a data frame with two columns: 
      # one for protein names and one for their corresponding colors.
      group_annotated <- stack(net_results[[group_index_value]]$colors) %>% 
        rename(protein = ind, module = values) %>%
        left_join(annotations, by = "protein") %>%  
        group_by(module) %>%
        drop_na(KEGG_ko) %>%
        mutate(ko_extraction = str_split(KEGG_ko, ",")) %>%
        unnest(ko_extraction) %>%
        mutate(ko = str_extract(ko_extraction, "ko:(K\\d+)", group = 1)) %>%
        select(-KEGG_ko, -ko_extraction)
      
          # Perform enrichment analysis for each module
    enrichment_results <- group_annotated %>%
        group_by(module) %>%  # Group by module
        summarize(ko_genes = list(ko), .groups = 'drop') %>%  # Collect KO genes by module
        
      #Convert enrichment_result to Data Frame:
      mutate(enrichment_result = map(ko_genes, ~ {
            result <- clusterProfiler::enricher(.x, TERM2GENE = term2gene)
            as.data.frame(result)  # Convert to data frame
        })) %>%
        unnest(enrichment_result) %>%  # Unnest results
        select(-ko_genes) %>%  # Drop the KO genes column if not needed
        rename(pathway = ID) %>%  # Rename the ID column
        mutate(group_index = group_index_value)  # Add group index

    pe_analyses[[i]] <- enrichment_results
}

final_results <- bind_rows(pe_analyses)

if (!interactive()) {
    pe_analyses %>% write_rds_and_tsv("modules_Kegg_enrichment")
}

```

```{r manual sheet}
# extract their column name and assgin correponsing group_index to them.
#data.frame(group_index= rep(2, ncol(result_pheno_H$p_value)), module = as.vector(gsub("ME", "", colnames(result_pheno_L$p_value))))


all_frames <- list()

# Step 1: Create a master character vector containing the object names
master_object_names <- c("result_pheno_L$p_value", "result_pheno_W$p_value", "result3$p_value", "result3.1$p_value", "result3.2$p_value")

values_group_index <- c("5","6","4","2","3")

# Step 2: Loop through the object names and access the actual objects using get()
for (i in 1:length(master_object_names)) {
  
  # Use get() to access the object by its name
  current_object <- eval(parse(text = master_object_names[i]))
  
  # Print the object or perform operations on it
  print(current_object)
  
  #turn into new dataframe
  current_frame <- data.frame(group_index= rep(values_group_index[i], ncol(current_object)), 
                              module = gsub("ME", "", colnames(current_object)))
  
  all_frames[[i]] <- current_frame
  
   # then can perform other operations here using `current_object`
}

all_frames <- do.call(rbind, all_frames)

new_row <- data.frame(group_index = 1, module = gsub("ME", "", key_module))

final_frames <- rbind(all_frames, new_row)
```


```{r eval = FALSE}
# --- plots

final_results <- final_results %>% mutate(mod_grp = paste(module, group_index, sep = "_"))
final_frames <- final_frames %>% mutate(mod_grp = paste(module, group_index, sep = "_"))


# Simple tile showing pathways and modules

#for(i in 1:length(unique(final_results$group_index))) {

generate_Keggplot <- function(group_indices, title_suffix) {
 
   j <- final_results %>% 
    filter(mod_grp %in% final_frames$mod_grp) %>%
    left_join(pathway_hierarchy, by = "pathway") %>%
    filter(!str_detect(pathway_class, "^09160|09190|09180")) %>%   # Exclude unwanted pathways
    filter(group_index %in% group_indices)
  
   # Convert to wide format
    dist_data <- j %>%
      pivot_wider(id_cols = module, names_from = pathway, values_from = p.adjust, values_fill = 0) %>%
      drop_na(module) 
    
    # Check if there are enough modules for clustering
    
    if (nrow(dist_data) >= 2) {
      # Calculate distance and perform hierarchical clustering
      dist_matrix <- dist(dist_data[, -1], method = "binary")  # Exclude the first column (module)
      dist_ <- hclust(dist_matrix)
      
      # Create the plot
    plot_m <- j %>%
      mutate(module = factor(module)) %>%
      ggplot(aes(pathway, forcats::fct_inorder(module), col = pathway_class)) +
      geom_point(size = 2) +
      scale_x_discrete(drop = FALSE) +
      facet_grid(group_index ~ ., scales = "free", space = "free") +
      theme_minimal() +
      theme(
        axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = 10),
        axis.text.y = element_text(size = 12),
        panel.grid.minor.x = element_blank(),
        legend.text = element_blank(),
        legend.title = element_blank()
      ) +
      labs(
       title = paste0("Group indices: ", paste(group_indices, collapse = ", "), title_suffix),
        x = "Kegg pathways (adj-p < 0.05)",
        y = "Emission related modules"
      ) +
      coord_flip()

    return(plot_m)
  } else {
    message("Not enough data for clustering for group indices: ", paste(group_indices, collapse = ", "))
    return(NULL)
  }
}


# Generate plots for the two groups
#plot_group1 <- generate_Keggplot(c(1, 2, 3), " (Groups 1, 2, 3)")
plot_group1 <- generate_Keggplot(c(1, 2, 3), " ") #H: 1600 W:900
plot_group2 <- generate_Keggplot(c(4, 5, 6), " ")


# Combine the two plots using plot_grid
if (!is.null(plot_group1) && !is.null(plot_group2)) {
  combined_plot <- cowplot::plot_grid(plot_group1, plot_group2, ncol = 2)
  print(combined_plot)

  # Save the combined plot as a file
  ggsave("pathway_combined_groups.png", plot = combined_plot, width = 12, height = 14)
} else {
  message("One of the plots was not generated due to insufficient data.")
}
```


### Interesting module

```{r}

data.frame(CH4_dmi = meta_cln[rownames(Archbac_protmics),]$ch4_dmi_binary, Proteomics = Archbac_protmics$MEdarkgreen) %>% 
   #mutate(CH4_dmi = factor(CH4_dmi)) %>% 
   ggplot(aes(x = CH4_dmi, y = Proteomics)) +
    #geom_boxplot(aes(colour = CH4_dmi), outlier.shape = NA, alpha = 0.5) +
    geom_point(aes(colour = CH4_dmi),size = 2, alpha = 0.5) +
    geom_smooth(method = "lm", formula = y ~ as.numeric(x)) +
    stat_cor(label.y = max(Archbac_protmics$MEdarkgreen)+0.05) +
    scale_colour_gradient(low = "#66FF33", high = "#FF3399") +
    #stat_compare_means(label = "p.format", tip.length = 0, vjust = 0.5) +
    ggtitle("Module: darkgreen")


```

```{r eval = FALSE}
# Step 1: Create a master character vector containing the proteomics matrix names
master_protmics_names <- c("Ciliates_protmics", "Fungi_protmics", "Metazoa_protmics", "MetLiver_protmics", "MetWall_protmics" ) 

master_correlation_cols <- c("result3.1", "result3.2", "result3", "result_pheno_L", "result_pheno_W")

plot_list <- list()

# Step 2: Loop through the object names and access the actual objects using get()
for (i in seq_along(master_protmics_names)) {
 
  # Use get() to access the object by its name
  current_protmics <- get(master_protmics_names[i])
  current_ME <- get(master_correlation_cols[i])$p_value
  
  
  
  # Check if the current_protmics or current_ME is empty
  if (is.null(current_protmics) || ncol(current_protmics) == 0 || is.null(current_ME) || ncol(current_ME) == 0) {
    message(paste("Skipping", master_protmics_names[i], "due to missing data."))
    next
  }
  
  # Create a list to store plots for the current proteomics matrix
  current_plot_list <- list()
  
  # Loop through the correlation columns for the current matrix
  for (j in seq(1, ncol(current_ME))) {
    
    # Create the data frame for plotting
    current_frame <- data.frame(
      CH4_dmi = meta_cln[rownames(current_protmics), ]$ch4_dmi_binary, 
      #archbac_ME = Archbac_protmics
      Proteomics = current_protmics[, colnames(current_ME)[j]]
    )
    
    
    # Check if the data frame has valid data for plotting
    if (any(is.na(current_frame$CH4_dmi)) || any(is.na(current_frame$Proteomics))) {
      message(paste("Skipping plot for", master_protmics_names[i], "column", colnames(current_ME)[j], "due to missing values."))
      next
    }
    
    
    # Generate the scatter plot for the current correlation
    plot_m <- current_frame %>%
      ggplot(aes(x = CH4_dmi, y = Proteomics)) +
      geom_point(aes(colour = CH4_dmi), size = 2, alpha = 0.5) +
      geom_smooth(method = "lm", formula = y ~ as.numeric(x)) +
      stat_cor(label.y = max(current_protmics[, colnames(current_ME)[j]], na.rm = TRUE) + 0.05) +
      scale_colour_gradient(low = "#66FF33", high = "#FF3399") +
      ggtitle(paste(master_protmics_names[i], colnames(current_ME)[j], sep = " ")) +
      theme_minimal() +
      theme(
        plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
        axis.text.y = element_text(size = 10),
        legend.position = "bottom"
      )
    # Save the plot to the current list
    current_plot_list[[j]] <- plot_m
  }
  
  # Check if `current_plot_list` is not empty before combining
  if (length(current_plot_list) > 0) {
    # Combine all plots for the current proteomics set into one grid
    combined_plot <- cowplot::plot_grid(plotlist = current_plot_list, ncol = 2)
    # Add the combined plot to the overall list
    plot_list[[master_protmics_names[i]]] <- combined_plot
    
    ggsave(paste("all_proteomics_correlation_plots-", master_protmics_names[i],".pdf", sep = ""), combined_plot, width = 16, height = 5 * (length(current_plot_list) / 2))
  } else {
    message(paste("No valid plots created for", master_protmics_names[i]))
  }
}

# Check the contents of the final plot list
message("Final Plot List Summary:")
print(names(plot_list))

```

```{r eval = FALSE, include = FALSE}

for (i in seq_along(names(plot_list))){

#Save and display the combined plots for each proteomics set
# Arrange the plots based on grouping and display them together
final_combined_plot <- cowplot::plot_grid(plotlist = plot_list[names(plot_list)[i]], ncol = 1)#, labels = names(plot_list))

# Save the final combined plot
ggsave(paste("all_proteomics_correlation_plots-", names(plot_list)[i],".pdf", sep = ""), final_combined_plot, width = 16, height = length(plot_list[i])
}

```

```{r}
save(meta, combined_MAG_genome, metadata, groups, file = "Omnicorr_cow_meta_traits.RData")
```

